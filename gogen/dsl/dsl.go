package dsl

import "strings"

// sanitizeMapKeyName returns a trimmed name and a lowercase keyname
func sanitzeMapKeyName(key string) (string, string) {
	key = strings.TrimSpace(key)
	return strings.ToLower(key), key
}



/*

//CommandExpr defines the command a aggregate accepts
func CommandExpr(name string, dsl ...func()) {
	handlesCommands, ok := handlesCommands()
	if !ok {
		dslengine.IncompatibleDSL()
		return
	}

	if len(dsl) > 1 {
		//error cannot have more than one dsl
		dslengine.ReportError("cannot have more than one dsl functions, only the first is used")
	}

	key, name := sanitzeMapKeyName(name)

	command, ok := Root.Commands[key]
	if !ok {
		command = NewCommandDefinition(name)
		Root.Commands[key] = command
	}

	if len(dsl) >= 1 {
		dslengine.Execute(dsl[0], command)
	}

	handlesCommands[key] = command
}

//GenerateEvents provides the events that are generated by the root aggregate
func GenerateEvents(dsl func()) {
	aggregate, ok := aggregateRootDefinition()
	if !ok {
		dslengine.IncompatibleDSL()
		return
	}

	dslengine.Execute(dsl, aggregate.GeneratesEvents)
}

//Event defines the event
func Event(name string, dsl ...func()) {
	key, name := sanitzeMapKeyName(name)

	if len(dsl) > 1 {
		//error cannot have more than one dsl
		dslengine.ReportError("cannot have more than one dsl functions, only the first is used")
	}

	event, ok := Root.Events[key]
	if !ok {
		event = NewEventDefinition(name)
		Root.Events[key] = event
	}

	switch def := dslengine.CurrentDefinition().(type) {

	case GeneratesEventDefinition:
		def[key] = event
	case HandlesEventDefinition:
		def[key] = event
	default:
		dslengine.IncompatibleDSL()
	}

	if len(dsl) >= 1 {
		dslengine.Execute(dsl[0], event)
	}
}

//ProjectionExpr defines a projection
func ProjectionExpr(name string, dsl func()) *ProjectionDefinition {
	generator.Register()

	key, name := sanitzeMapKeyName(name)

	if _, ok := Root.Projections[key]; ok {
		dslengine.ReportError("duplicate projeciton defined, already one defined with the same name `%s`", name)
		return nil
	}
	projection := NewProjection(name)
	projection.DslFunc = dsl
	Root.Projections[key] = projection

	return projection
}

// ProjectionExpr handles the following events
func HandlesEvents(dsl func()) {
	projection, ok := projectionDefinition()
	if !ok {
		dslengine.IncompatibleDSL()
		return
	}
	dslengine.Execute(dsl, projection.HandlesEvents)
}

// sanitizeMapKeyName returns a trimmed name and a lowercase keyname
func sanitzeMapKeyName(key string) (string, string) {
	key = strings.TrimSpace(key)
	return strings.ToLower(key), key
}
*/